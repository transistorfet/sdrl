
	* fix the disperr.c function since it will no longer print error messasges correctly

	* implement a simple regular expression matcher as seen in beautiful code. It is simple, functional,
	  and more importantly, it needs more builtin functions (the ability to get chars in a string)

	* make libraries namespacable
	* convert bindings into a hash table
	* think about retract_environment and references (potential problems? see code)
	* add const to all parameters that you can
	* there is probably a memory leak in error.c particularily in sdrl_set_error where the contents
	  of last_error are overwritten without first freeing possibly existing error.  (I need to dig into
	  it more but i don't really like the way i wrote errors anyways)

	* should we rename "ret" in sdrl_machine to something more appropriate such as acc or accumulator
	* rename sdrl_load_<lib> to sdrl_load_canonical_<lib>
	* should we rename sdrl_call_value to sdrl_evaluate_value?

	* make string functions: strcmp, substr, char, uppercase, lowercase
	* make equals command check any type instead of just number
	* change the name/format of bitflag test macros or else use bitfields (sdrl_event's SDRL_USE_RET)

	* add a comment to all library functions and types describing the
	  parameters taken through struct sdrl_value *value

	* machine value type with a pointer to a machine structure (for calling a function in another machine)
	* a function to automatically check args based on min/max args allowed? (both in C and SDRL)
	* function to check types (in libbase??)

	* add support for threads (either in the core or in a lib)
	* make a heap implementation
	* make parser catch errors during a parse

	* better way to initialize libraries?

	* what about expr type in relation to destroy() (creating an expr value that is not a function or mach->code)
	* add constant values (modifier to value or bitflags in type?)
	* can we simplify the semantics of set?

	* add garbage collection
	* allow multiple event stacks in a continuation
	* make the parser parse syntactic sugary goodness
	* make the parser modifiable by the code itself
	* add cross-cutting language constructs (aspects?)
	* can you do aspects using the continuation stack or should you do it by modifying the expr tree


