
	* you could, as a possible compromise, have an array of some kind in the machine struct with pointers
	  to certain types with known indicies so that you can easily get the type pointer.  This might also
	  have benifits in changing the actual type used in a given situation but then again, the functions
	  statically referenced like make_string will still be called
	* should you use a common heap instead of a seperate heap for each machine?  It would allow more
	  easy sharing of values (no need to worry about which machine has which value) and it would pose
	  fewer concerns to a pointer-based type system.  Lua uses a function pointer to realloc passed to
	  it when initialized so that you can pass it a custom allocation function to keep instances isolated
	  if you want.

	* make error macros for certain known common errors like sdrl_set_type_error(), etc
	* make macro to check the number of args and set an error if not matched
	* add inheritence to types even without going to the pointer-based type system

	* lexblock, dynblock, and expr type evaluate funcs set the args to be a value in the env but the
	  first arg is the function itself.  Should it be removed from args first?
	* should you change all function names to be sdrl_<type>_<function> such as sdrl_expr_destroy,
	  sdrl_env_duplicate, etc?
	* what should happen with the array manipulation functions in terms of who is responsible for
	  creating a reference for the value being stored in the array?
	* look at python and perl in terms of reference management and try to make reference management
	  (who creates and destroys references) easier to follow such that you avoid reference-based bugs
	* should we delete utils.c since it's not really used now
	* you *have* to look into how things will work with librarys loaded dynamically with respect to
	  having access to type variables.  You may want to have both type systems at once
	* should you move sdrl_set_error to error.c?

	* make basetypes all seperate files complete with support functions
	* put lib type stuff in a seperate file rather than base.h or wherever
	* reduce length/verbosity of some function names (as per api.txt?)
	* use void functions where appropriate
	* make error a value

	* add an 'undef' value to be used in place of actual NULL values (alternately check for NULL in libs)
	* make a new list type sdList { sdValue value, sdValue *ref, sdList *next }
	* move to pointer-based type system to speed up core, saving the type lookups
	* add the pop/unshift realloc downsizing code (if at all)
	* make functions for push, pop, shift, unshift
	* make a duplicate environment function

	* make functions (inlines) for things like sdrl_env_find that produce an error such that they
	  can easily be used with SDRL_TRY()
	* use SDRL_TRY everywhere you can, including the core
	* should sdrl_make_call_expr really by called sdrl_make_expr_expr (despite it's strangity?)
	* add cplusplus checks to headers that add an extern "C" { } block

	* rewrite lib functions to use the conversion/newfancy funcs

------------

	* make a function called "make" or "new" that takes a typename and args and creates that type
	  using the type's create function.  (make env *globals*) ; make an env that extends *globals*

	* add AST traversers that convert "if" and various other syntactic "features" into pure "SDRL"
	  format (verbose).  This prevents the need for a special parser but still has a lot of benifits
	  and is much more configurable, even though it probably would be slower (a custom parser would be
	  for speed and for complex syntax)
	* add a basic object oriented system

	* should you remove the severity number from sdrl_set_error?

	* add flags to the machine or something such that a program can change certain (what might be compiled
	  in atm) options, such as treating "namespace.name" type names as special (causing a recursive lookup)
	* should it be possible to set the parser on the command line or somethnig?
	* make regression tests to test all aspects of the base library extensively
	* make (if there isn't one already) a function that takes a string and evaluates it as code
	* review 'lookup', 'set', & 'setlist' and cleanup

	* make a hash string value (type?) and modify bindings to take a precalculated hash and then
	  use those functions as often as possible and make language bindings to support it so you can use
	  the values directly in order to speed up accesses when you know the hash will not otherwise be
	  preserved

	* make string functions: strcmp, uppercase, lowercase
	* make libraries namespacable
	* add a namespace command.  Should it be a form or a function? (namespace foo (code (set num 2)))
	* add a 'load' command that (somehow) calls the library loading function that adds all the library
	  bindings to the environment.  I don't know how, sematically, this will work with namespaces such
	  that each library behaves in an expected way.  Doing it like python might be good

	* make the output of dispexpr.c more readable
	* make parser catch errors during a parse
	* make the lambda parser support hex and octal number representation

	* rewrite event.c to use a preallocated set of events (???)
	* make equals and nequals more generic (not just numbers)
	* machine value type with a pointer to a machine structure (for calling a function in another machine)
	* optimize the hash function
	* add the ability to make a reference constant

	* get an autodoc creator setup

Refactoring:

	* should retract_environment replace destroy_environment (in name)
	* should we rename "ret" in sdrl_machine to something more appropriate such as acc or accumulator
	* rename sdrl_load_<lib> to sdrl_load_canonical_<lib>
	* can you convert to using enums?  what are the drawbacks with regards to backwards compatibility?
	* should you move the number and string types to libbase and move the basetypes into utils?

Tests:

	* should tests be categorized particularily with respect to the libraries being tested?
	* implement a simple regular expression matcher as seen in beautiful code. It is simple, functional,
	  and more importantly, it needs more builtin functions (the ability to get chars in a string)
	* a brainfuck interpreter
	* write an IRC client/bot that uses SDRL quite integrally (rather than as an extension like stutter)

Structural Issues:

	* pthyon uses type pointer variables (possibly initialized during runtime as opposed to static
	  although I'm not sure).  It then refers to those type variables directly instead of how I'm
	  doing it with a type environment.  I like this method better because it's much faster to do
	  type comparisons.
	* should you make types constant like you have done in sdm, stutter, and such? (see notes.txt)
	* should you have a more robust object system with a proper "init/release" type function for each
	  type?  It will allow for better inheritance in exchange for a slight performance loss.  There is a
	  chance we will have problems with environment since the actual struct will first be allocated so
	  there must be a way, after that's occurred, to create a new env or to extend an existing one.
	  Another issue is strings.  We currently allocate strings as a single block since strings are not
	  intended to be *directly* changed, instead a new string value will be created.
	* a possible way to remove the string and number types from the core (allowing for alternate
	  implementations) would be change expr to hold either an identifier, a value, or an expr, and
	  have the parser convert all strings and numbers to values.  The downsides of this is that the
	  parser would then have to know about the types somehow and also any identifiers in the expr would
	  not be convertable into strings during interpretation.  One benifit of this however, is the
	  ability of the parser to directly accept literals for things that are not numbers or strings such
	  as lists of literals, complex numbers, etc.  It would also be possible to use a "macro/ast mod"
	  system to convert and verify the AST before actual execution such that all identifiers are properly
	  converted into whatever they should be (either direct function names or turned into value lookups
	  with strings instead of identifiers).  This would get around the downside part and possibly result
	  in faster evaluations.
	* another possible way to remove number and string types from the core is if you had subtypes for
	  exprs and have a function in the type that can be called to turn the expr into a value.  The
	  function and thus the expr type would have to be outside of the core and the parser would have
	  to know about the type but since that's outside of the core too, the type itself doesn't have to
	  be in the core.
	* is there a benifit to having multiple event stacks?  Perhaps the ability to package up the current
	  stack when an error has occured and start executing an exception handler function on a completely
	  different stack.  Another possible use would be in multithreading however it might be more useful
	  to make a completely different machine structure for each thread and give each machine a reference
	  to the same global environment in order to achieve the "shared memory" of threads.
	* should you make expr more like all values in that you have a "subclass" for each type of expr
	  (number, string, expr). struct sdNumberExpr { sdExpr expr; number_t num };  This would allow
	  you to get rid of the union (not that big a deal) but also to easily make alternate expr types
	  such as one that contains an sdValue.
	* should it be possible somehow (perhaps it's undesirable) to directly make new "types" via the
	  language itself, as opposed to making "types" via an environment-based object system?  Is this
	  even useful since the benifit to types is mostly in C.  Does this also mean that it's actually
	  better to have *fewer* C-based types since we need extra support functions for manipulating them?
	* what do you do if a value being applied/evaluated is non-executable (does not have an evaluate
	  function in it's type)?  Should you just return the value?  Should it be an error?  This "feature"
	  is exploited by "if" such that it calls its params like a function but if they aren't (code ) blocks,
	  it expects that the call will result in the value passed being returned.
	* re-evaluate the reference tracking in the environment functions (extend/retract) particuarily with
	  respect to the fact that extending mach->env needs to take into account that mach->env's reference
	  needs to be destroyed.  Should extend steal the environment reference it's given (thus you just need
	  to make a reference whenever you extend an env other than mach->env
	* possibly add caching to environments.  The easiest way to allow full caching is to store a bitflag
	  with a cache entry to signify it as such so that when you destroy the entry, you don't call the
	  destroy function.  The trouble though is when the original entry is destroyed somehow for some
	  reason (or is even reassigned).  The cache entry will then be invalid.  A less efficent alternative
	  could be to store a pointer to the env containing the entry instead.  What about though if an
	  inbetween env creates a new entry that overrides the previous one?  Why wouldn't a reference work in
	  this case? (maybe it will)
	* should you make a different dedicated hash table implementation for types to speed up type
	  discovery?  We shouldn't make types be values since we can instead make a 'type' type that is a
	  pointer to the type and use that as the actual value
	* how will set and setlist work with regards to the value/args? Should it duplicate the arg before
	  assigning it, steal the reference (clobber the args) or make a reference?  The make reference
	  method didn't seem to work in setlist because we actually need to clobber the args given the
	  way we use the next field =(

Features:

	* add support for threads (either in the core or in a lib)
	* add garbage collection
	* a parser that supports various syntactic sugar (using yacc/bison?)
	* cross-cutting language constructs (aspects?) (can you do aspects using the continuation stack or
	  should you do it by modifying the expr tree)


