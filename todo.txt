
	* convert all library functions to use the new utils functions
	* make string functions: strcmp, substr, uppercase, lowercase
	* make equals command check any type instead of just number

	* get an autodoc creator setup
	* make as many of machine's evaluate functions static as possible (all the dangerous intermediate type
	  ones)

	* make libraries namespacable
	* add a namespace command.  Should it be a form or a function? (namespace foo (code (set num 2)))
	* add a 'load' command that (somehow) calls the library loading function that adds all the library
	  bindings to the environment.  I don't know how, sematically, this will work with namespaces such
	  that each library behaves in an expected way
	* make the output of dispexpr.c more readable
	* add the ability to make sdrl_value constant (modifier to value or bitflags in type?) (or do you
	  really only need/want to make a binding constant?)
	* add an easy way to make a value that refers to a static piece of data (that you don't call destroy
	  on) without the need for 2 types for everything
	* make parser catch errors during a parse
	* can we without too much trouble make the string type record the length as well?

	* should we rename "ret" in sdrl_machine to something more appropriate such as acc or accumulator
	* rename sdrl_load_<lib> to sdrl_load_canonical_<lib>
	* should we rename sdrl_call_value to sdrl_evaluate_value?
	* can you convert to using enums?  what are the drawbacks with regards to backwards compatibility?

	* add a function to automatically check args based on min/max args allowed and types? (both in C and
	  SDRL)
	* what about expr type in relation to destroy() (creating an expr value that is not a function
	  or mach->code)  (wtf was i talking about here?)
	* can/should we simplify the semantics of set?  Perhaps making 2 different functions
	* machine value type with a pointer to a machine structure (for calling a function in another machine)
	* allow multiple event stacks in a continuation (what is this actually for? a thread type of thing?)
	* make the lambda parser support hex and octal number representation

	* can we somehow perform the check for a string's length without the call the strlen in string:char?

Tests:

	* should tests be categorized particularily with respect to the libraries being tested?
	* implement a simple regular expression matcher as seen in beautiful code. It is simple, functional,
	  and more importantly, it needs more builtin functions (the ability to get chars in a string)
	* a brainfuck interpreter

Structural Issues:

	* should you make a trackable_oject type struct that all objects that are trackable/garbage
	  collectable such as values and environments (types too?) inherit so you can cast them and deal with
	  them more nicely?  Would this also make it better for libraries that want to get in on the GC
	  action?  Would this struct contain the pointer to the heap in addition to just the ref num?
	* we need to be able to reference count/track the expr datatypes because we store pointers to them
	  but in most situations, we will parse stuff into expr, evaluate the expr, and then throw it away
	  but keep the same machine (and want any functions for example added to the system to stay).
	* what do you do if a value being applied/evaluated is non-executable (does not have an evaluate
	  function in it's type)?  Should you just return the value?  Should it be an error?  This "feature"
	  is exploited by "if" such that it calls its params like a function but if they aren't (code ) blocks,
	  it expects that the call will result in the value passed being returned.
	* you need to come up with a namemangle or something that is reserved for interpreter use such that
	  special variables are named that way (like the global environment, the error handling function, etc)
	* re-evaluate the reference tracking in the environment functions (extend/retract) particuarily with
	  respect to the fact that extending mach->env needs to take into account that mach->env's reference
	  needs to be destoyed.  Should extend steal the environment reference it's given (thus you just need
	  to make a reference whenever you extend an env other than mach->env
	* should we distinguish between bareword strings and quoted strings in exprs which would at least give
	  us the choice to act differently (ie. always do a lookup on barewords)?
	* the type system needs some redesigning.  The parameters are inconsistent.  You need to determine
	  how the create function will truely work.  Should it return the value instead just a pointer? same
	  with duplicate.  Destroy seems a bit funny just taking the heap (but that makes it easy to use the
	  sdrl_destory_value function).  What about the parameters to the type create function?  Is that
	  function primarily for direct calling from SDRL or direct calling from C?
	* possibly add caching to environments.  The easiest way to allow full caching is to store a bitflag
	  with a cache entry to signify it as such so that when you destroy the entry, you don't call the
	  destroy function.  The trouble though is when the original entry is destroyed somehow for some
	  reason (or is even reassigned).  The cache entry will then be invalid.  A less efficent alternative
	  could be to store a pointer to the env containing the entry instead.  What about though if an
	  inbetween env creates a new entry that overrides the previous one?

Features:

	* add support for threads (either in the core or in a lib)
	* add garbage collection
	* a parser that supports various syntactic sugar
	* cross-cutting language constructs (aspects?) (can you do aspects using the continuation stack or
	  should you do it by modifying the expr tree)


